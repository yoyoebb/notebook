#+SETUPFILE: ~/.emacs.d/org-templates/level-2.org
#+TITLE: Number

* 数的分类
按照人类历史对数字的认识过程，我们可以把数分为：
** 自然数(Natural) 
在数东西的时候使用的数，即大于等于0的整数，如：0,1,2,3,4,5,...
** 整数(Integer)
负整数、0、正整数，如：...,-5,-4,-3,-2,-1,0,1,2,3,4,5,...，在此基础上我们可以进行四则运算(add、substract、multiply、divide)，但对整数做除法运算后，其结果往往不再是整数。
** 有理数(Rational)
为了支持除法运算的封闭性，数学家们引入了有理数的概念，任意一个有理数都可以表示成 ~m/n~ 的形式(其中 m,n都为整数，且n不为0)

有理数的概念在公元前5世纪，由古希腊的毕达哥拉斯学派(毕达哥斯拉首次系统证明了勾股定理)发扬光大，“数为万物之本”甚至成了他们的哲学。他们对整数做了进一步细分：
  + 奇数
  + 偶数
  + 质数
  + 亲和数
  + 完全数
** 无理数
看起来世界终于守序了，但不幸的是，毕学派内部出了个“叛徒”，其中一个成员，希帕索斯发现，边长为1的正方形，其对角线长度无法用整数或分数来表示(即不可通约)，于是数学史上第一个无理数出现了，它被命名为 \radic{}2。无理数的发现，推翻了毕学派的高楼，当时的人们完全无法理解这一数学含义，他们直接把希帕索斯扔进了大海淹死，但这样做也解决不了问题，“第一次数学危机“爆发了。

这个问题在公元前370年，由柏拉图的学生攸多克萨斯解决了，他用公理化的形式创立了新的比例理论，微妙地处理了 可通约 和 不可通约，并被欧几里得收录到《几何原本》第二卷。从那以后，希腊人就在几何的道路上越走越远，直到一条道走到黑。

越来越多的无理数(也被称为无限不循环小数)出现了，常见的有 \radic{}非完全平方数, \pi{}圆周率 , e欧拉数 等。 
** 实数(Real)
直到17世纪，数学家们才慢慢接受了无理数的存在，并把它和有理数平等看待，1871年，德国数学家康托尔首次提出了实数的概念，它包含有理数和无理数，但直到函数、极限和收敛性的概念都被定义清楚之后，实数的数学含义才由19世纪末的戴德金、康托等人严格定义。
** 虚数
** 复数
* 有效数字
** Significant digits
什么是significant digits(有效数字)?:
  - 所有非零的数字：1-9
  - 非零数字之间的零：102，2005，50009
  - 小数位后面第一个非零数字后的零：2.02000(6)，5.400(4)，0.05400(4)
  - 第一个非零数字前的零都不是有效数字：0.02(1)，001.887(4)，0.000515(3).
  - 整数位的trailing 0都不是有效数字：100(1), 320000(2)
* 计算机里的数字
数学上的数字，我们通常采用十进制形式来表示，但是在计算机的二进制世界里，只有'0'和'1'的存在，这些数字在底层又该怎么表示呢？
 
** 整数部分和小数部分的二进制转换
实数可以由整数部分和小数部分(有限、无限不循环、无限循环)组成，它们的二进制转换方式并不相同。
 + 整数转换，用整数部分/2取余，再用结果作为新的被除数，重复直至被除数为0，形成的余数序列倒置后即为该整数的二进制串。
   #+BEGIN_EXAMPLE
   6转换为二进制：
   6 / 2 = 3, Rem = 0
   3 / 2 = 1, Rem = 1
   1 / 2 = 0, Rem = 1
   最终结果: 6的二进制串为 110
   #+END_EXAMPLE
   通过这种方式，所有的整数都可以被转换为有限位数的二进制串。
 + 小数转换，用小数部分*2取整，再用剩余小数作为新的乘数，重复直至乘数为0，形成的整数序列即为该小数的二进制串。
   #+BEGIN_EXAMPLE
   0.6转换为二进制：
   0.6 * 2 = 1.2, 整数 = 1
   0.2 * 2 = 0.4, 整数 = 0
   0.4 * 2 = 0.8, 整数 = 0
   0.8 * 2 = 1.6, 整数 = 1
   0.6 * 2 ...               //开始循环
   最终结果: 0.6的二进制串为1001 1001 1001 ...
   #+END_EXAMPLE
   可以看到，大部分的有限小数，到了二进制世界反而不能精确描述了。

** 定点数(fixed)和浮点数(float)
转换的方法是有了，但由于小数很难精确转换成二进制串的特性，用什么合适的方法去存储，仍难是个大难题。科学家们想出了主要的两种方法：
 + 定点数(fixed point number)  \\
   所谓定点数就是小数点位置是固定的，在定义类型时，我们通常会指定 ~precision~ 精度(字段长度) 和 ~scale~ 范围(小数位数)。如：Number(5,2)就可以表示 -999.99 到 999.99 之间的所有两位小数的数字。在数据库中我们可以分段存储其整数部分和小数部分，实现起来比较简单，但也有一些问题：
   - 作为基本类型，不利于同时表达特别大的数和特别小的数(会带来很大的储存开销)

 + 浮点数(floating point number)  \\
   为了更加灵活，数学家们参考科学计数法，为计算机设计了浮点计数法(小数点的位置是浮动的)，并由此形成了IEEE 754标准。标准里面定义了两种精度：单精度32位浮点数、双精度64位浮点数。

   [[../../images/Basic/IEEE_745.png]]
   
   由此一个实数可以表示为: (-1)^{sign} * (1+fraction) * 2^{exponent-bias}
   - 当实数为正数时，sign=0，为复数时，sign=1
   - 根据公式，给定实数x, x / 2^{power} = (1+fraction)，即fraction可以通过 x 除以 2^{n} 得到
   - exponent = bias + power

让我们看一个将实数转为浮点数的实际例子，e.g, 将0.085转换为single-precision format。
 1. 确定sign。因为0.085是正数，所以 sign bit=0。
 2. 确定fraction和power                 \\
    0.085 / 2^{-1} = 0.17               \\
    0.085 / 2^{-2} = 0.34               \\
    0.085 / 2^{-3} = 0.68               \\
    0.085 / 2^{-4} = 1.36               \\
    所以 fraction=0.36，power=-4, exponent=bias+power=127+(-4)=123
 3. 利用整数转二进制的方法，得到exponent的二进制串：0111 1011
 4. 利用小数转二进制的方法，得到fraction的二进制串：0101 1100 0010 1000 1111 011...
 5. 得到最后的结果：
    |         | sign | Exponent  | Fraction                      |
    |---------+------+-----------+-------------------------------|
    | Decimal |    0 | 123       | 0.36                          |
    | Binary  |    0 | 0111 1011 | 0101 1100 0010 1000 1111 0111 |

** 浮点数的精度和范围
 + 浮点数的范围由exponent控制
   - float : -2^128 ~ 2^128_{bin}, 即 -3.4E+38 ~ 3.4E+38_{ten}
   - double: -2^1024 ~ 2^1024_{bin}, 即-1.79E+308 ~ 1.79E+308_{ten}

 + 浮点数的精度由 1+fraction 控制
   - float : 2^24 = 16,777,216 , 提供6-7位significant digits
   - double : 2^53 = 9,007,199,254,740,992 , 提供15位significant digits

*这里需要强调的是，N位significant digits并不意味着前N位数是精确的。*   \\
*解惑*: float只提供了1+23位fraction共24位bit的情况下，如果实数转化为二进制串后长度超过24，则会发生bit位舍入而导致的精度丢失。(舍入原则是：1.最近原则(舍入到无精度丢失的最近的数) 2.偶数原则(距离相同，舍入到末尾是0的数))
#+BEGIN_EXAMPLE
我们假设保留3个bit位，之后的bit位进行最近舍入
111    111 (power=0)
1000   100 (power=1)  100(无精度丢失)
1001   100 ...        舍去位是1，100<x<101，距离相同取偶数，100
1010   101            101(无精度丢失)
1011   110            舍去位是1，101<x<110，距离相同取偶数，110
1100   110            110(无精度丢失)
1101   110            舍去位是1，110<x<111，距离相同取偶数，110
1110   111            111(无精度丢失)

1111   100 (power=2)  舍去位是1，111<x<100(进位)距离相同取偶数,100
10000  100 ...        100(无精度丢失) 
10001  100            舍去位是01，100<x<101，离100近，100
10010  100            舍去位是10，100<x<101, 距离相同取偶数，100

10011  101            舍去位是11，100<x<101, 离101近，101
10100  101            直接舍去无精度丢失
10101  101            最近原则，101

10110  110            偶数原则，110
10111  110            最近原则，101
11000  110            110(无精度丢失)
11001  110            最近原则，110
11010  110            偶数原则，110

11011  111            最近原则，111
11100  111            111(无精度丢失)
11101  111            最近原则，111

11110  100 (power=3)  偶数原则，100（进位）
11111  100 ...        最近原则，100
100000 100            100(无精度丢失)

#+END_EXAMPLE
 - 整数是可以精准地转化为二进制字符串。但是我们使用float只能正确保存 0~16,777,215(2^{24}-1)之间的所有整数(假设符号位为正)。但当超过16,777,215之后，部分整数开始出现精度丢失，并且整数越大，丢失的精度也就越多(一般能保证前7位有效数字，第8位开始出现舍入，舍入基数大约是2^{m-24}的级别)
 - 小数的话，除了所有的1/2^{n}的小数组合可以精准转化为二进制字符串，其他小数大多无法精确转化，只会往最近的可以精准转化的二进制字符串靠拢，对于float而言，也会出现2^{-24}，即 ~0.000,000,119,209,37~ 左右的精度丢失。也就是一般小数能保证前7位有效数字，从第8位开始进行舍入。
   #+BEGIN_EXAMPLE
   (3.0f - 2.9000001f)  == (3.0f - 2.9000002f)    //true
   (1.0f - 0.90000001f) == (1.0f - 0.90000002f)   //true
   #+END_EXAMPLE

** TODO 定点数和浮点数的运算

