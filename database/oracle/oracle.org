定义：
主键(PRIMARY KEY)	表通常具有包含唯一标识表中每一行的值的一列或一组列。这样的一列或多列称为表的主键 (PK)，用于强制表的实体完整性。
外键(FOREIGN KEY)	外键 (FK) 是用于建立和加强两个表数据之间的链接的一列或多列。在外键引用中，当一个表的列被引用作为另一个表的主键值的列时，就在两表之间创建了链接。这个列就成为第二个表的外键。
聚集索引	聚集索引基于数据行的键值在表内排序和存储这些数据行。每个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。
非聚集索引	非聚集索引包含索引键值和指向表数据存储位置的行定位器。可以对表或索引视图创建多个非聚集索引。通常，设计非聚集索引是为改善经常使用的、没有建立聚集索引的查询的性能。
自动编号列和标识符列	对于每个表，均可创建一个包含系统生成的序号值的标识符列，该序号值以唯一方式标识表中的每一行。
业务主键（自然主键）	在数据库表中把具有业务逻辑含义的字段作为主键，称为“自然主键(Natural Key)”
逻辑主键（代理主键）	在数据库表中采用一个与当前表中逻辑信息无关的字段作为其主键，称为“代理主键”。
复合主键（联合主键）	通过两个或者多个字段的组合作为主键。

使用逻辑主键的主要原因是，业务主键一旦改变则系统中关联该主键的部分的修改将会是不可避免的，并且引用越多改动越大。而使用逻辑主键则只需要修改相应的业务主键相关的业务逻辑即可，减少了因为业务主键相关改变对系统的影响范围。业务逻辑的改变是不可避免的，因为“永远不变的是变化”，没有任何一个公司是一成不变的，没有任何一个业务是永远不变的。最典型的例子就是身份证升位和驾驶执照号换用身份证号的业务变更。而且现实中也确实出现了身份证号码重复的情况，这样如果用身份证号码作为主键也带来了难以处理的情况。当然应对改变，可以有很多解决方案，方案之一是做一新系统与时俱进，这对软件公司来说确实是件好事。
         使用逻辑主键的另外一个原因是，业务主键过大，不利于传输、处理和存储。我认为一般如果业务主键超过8字节就应该考虑使用逻辑主键了，因为int是4字节的，bigint是8字节的，而业务主键一般是字符串，同样是 8 字节的 bigint 和 8 字节的字符串在传输和处理上自然是 bigint 效率更高一些。想象一下 code == "12345678" 和 id == 12345678 的汇编码的不同就知道了。当然逻辑主键不一定是 int 或者 bigint ，而业务主键也不一定是字符串也可以是 int 或 datetime 等类型，同时传输的也不一定就是主键，这个就要具体分析了，但是原理类似，这里只是讨论通常情况。同时如果其他表需要引用该主键的话，也需要存储该主键，那么这个存储空间的开销也是不一样的。而且这些表的这个引用字段通常就是外键，或者通常也会建索引方便查找，这样也会造成存储空间的开销的不同，这也是需要具体分析的。
         使用逻辑主键的再一个原因是，使用 int 或者 bigint 作为外键进行联接查询，性能会比以字符串作为外键进行联接查询快。原理和上面的类似，这里不再重复。
         使用逻辑主键的再一个原因是，存在用户或维护人员误录入数据到业务主键中的问题。例如错把 RMB 录入为 RXB ，相关的引用都是引用了错误的数据，一旦需要修改则非常麻烦。如果使用逻辑主键则问题很好解决，如果使用业务主键则会影响到其他表的外键数据，当然也可以通过级联更新方式解决，但是不是所有都能级联得了的。
         使用业务主键的主要原因是，增加逻辑主键就是增加了一个业务无关的字段，而用户通常都是对于业务相关的字段进行查找（比如员工的工号，书本的 ISBN No. ），这样我们除了为逻辑主键加索引，还必须为这些业务字段加索引，这样数据库的性能就会下降，而且也增加了存储空间的开销。所以对于业务上确实不常改变的基础数据而言，使用业务主键不失是一个比较好的选择。另一方面，对于基础数据而言，一般的增、删、改都比较少，所以这部分的开销也不会太多，而如果这时候对于业务逻辑的改变有担忧的话，也是可以考虑使用逻辑主键的，这就需要具体问题具体分析了。
         使用业务主键的另外一个原因是，对于用户操作而言，都是通过业务字段进行的，所以在这些情况下，如果使用逻辑主键的话，必须要多做一次映射转换的动作。我认为这种担心是多余的，直接使用业务主键查询就能得到结果，根本不用管逻辑主键，除非业务主键本身就不唯一。另外，如果在设计的时候就考虑使用逻辑主键的话，编码的时候也是会以主键为主进行处理的，在系统内部传输、处理和存储都是相同的主键，不存在转换问题。除非现有系统是使用业务主键，要把现有系统改成使用逻辑主键，这种情况才会存在转换问题。暂时没有想到还有什么场景是存在这样的转换的。
使用业务主键的再一个原因是，对于银行系统而言安全性比性能更加重要，这时候就会考虑使用业务主键，既可以作为主键也可以作为冗余数据，避免因为使用逻辑主键带来的关联丢失问题。如果由于某种原因导致主表和子表关联关系丢失的话，银行可是会面临无法挽回的损失的。为了杜绝这种情况的发生，业务主键需要在重要的表中有冗余存在，这种情况最好的处理方式就是直接使用业务主键了。例如身份证号、存折号、卡号等。所以通常银行系统都要求使用业务主键，这个需求并不是出于性能的考虑而是出于安全性的考虑。
         使用复合主键的主要原因和使用业务主键是相关的，通常业务主键只使用一个字段不能解决问题，那就只能使用多个字段了。例如使用姓名字段不够用了，再加个生日字段。这种使用复合主键方式效率非常低，主要原因和上面对于较大的业务主键的情况类似。另外如果其他表要与该表关联则需要引用复合主键的所有字段，这就不单纯是性能问题了，还有存储空间的问题了，当然你也可以认为这是合理的数据冗余，方便查询，但是感觉有点得不偿失。
        使用复合主键的另外一个原因是，对于关系表来说必须关联两个实体表的主键，才能表示它们之间的关系，那么可以把这两个主键联合组成复合主键即可。如果两个实体存在多个关系，可以再加一个顺序字段联合组成复合主键，但是这样就会引入业务主键的弊端。当然也可以另外对这个关系表添加一个逻辑主键，避免了业务主键的弊端，同时也方便其他表对它的引用。
        综合来说，网上大多数人是倾向于用逻辑主键的，而对于实体表用复合主键方式的应该没有多少人认同。支持业务主键的人通常有种误解，认为逻辑主键必须对用户来说有意义，其实逻辑主键只是系统内部使用的，对用户来说是无需知道的。

结论或推论：
1、尽量避免使用业务主键，尽量使用逻辑主键。
2、如果要使用业务主键必须保证业务主键相关的业务逻辑改变的概率为0，并且业务主键不太大，并且业务主键不能交由用户修改。
3、除关系表外，尽量不使用复合主键。


oracle用户与表空间关系
用户=商家
表=商品
表空间=仓库
1. 1个商家能有很多商品，1个商品只能属于一个商家
2. 1个商品可以放到仓库A，也可以放到仓库B，但不能同时放入A和B
3. 仓库不属于任何商家
4. 商家都有一个默认的仓库，如果不指定具体仓库，商品则放到默认的仓库中

oracle中用户的所有数据都是存放在表空间中的，很多个用户可以共用一个表空间，也可以指定一个用户只用某一个表空间。
表空间：创建表空间会在物理磁盘上建立一个数据文件，作为数据库对象（用户、表、存储过程等等）的物理存储空间；
用户：创建用户必须为其指定表空间，如果没有显性指定默认表空间，则指定为users表空间；创建用户后，可以在用户上，创建表、存储过程等等其他数据库对象；
表：是数据记录的集合；
创建过程： 表空间--->用户--->表;
所属关系： 表空间 包含 用户 包含 表；

JDBC连接ORACLE的两种方式：THIN、OCI
 jdbc:oracle:thin:@youroraclehost:1521:yoursid
 jdbc:oracle:oci:@youroracle-tns-name


服务器端：
NLS_DATABASE_PARAMETERS	服务器环境参数（语言、地区、日期格式、字符集。。。）
V$NLS_VALID_VALUES	支持的LANGUAGE 、TERRITORY、CHARACTERSET

客户端：
通过NLS_LANG环境变量设置：
NLS_LANG=<language>_<territory>.<client character set>， 如：AMERICAN_AMERICA.UTF8
LANGUAGE指定:
   -Oracle消息使用的语言
   -日期中月份和日显示
TERRITORY指定
   -货币和数字格式
   -地区和计算星期及日期的习惯
CHARACTERSET:
   -控制客户端应用程序使用的字符集

UTF8 ,  AL32UTF8
       Oracle的UTF8字符集由来已久，至少在8的时候就已经存在了，而对应的是UNICODE 3.0。而AL32UTF8字符集是9i才出现的，其对应的是UNICODE 5.0。这两种字符集的区别在于，UNICODE 5.0与3.0相比，又增加了一些新的补充字符。但是在实际当中，使用到这些新增字符的可能性非常小，因此绝大部分情况下，选择UTF8也是足够的。
       而对于数据库的访问而言，二者还是存在一定差异的。前面提到了AL32UTF8字符集是9i才出现的，那么对于9i以后的版本访问没有任何问题，但是对于8i及以前的版本，则不认识这个字符集。这就使得8i及更低版本的客户端在访问9i以上AL32UTF8的数据库时，会碰到各种各样的问题。因此，Oracle建议在选择AL32UTF8和UTF8字符集时，最关键的一点就是是否有8i及以下版本的客户端会登录到数据库中，如果没有则可以选择AL32UTF8，如果存在这种客户端，那么需要选择UTF8字符集。
       随着现在版本11g逐渐开始称为主流版本，8i客户端的情况已经越来越少见了，因此在11.2的DBCA中，UTF8已经不是推荐字符集列表中的一员了。

内置函数
转换函数：
ascii(字符) 字符转为数字。 返回字符（字符串则是首字符）对应的十进制数字  select ascii('ab') from dual ;
CHR(数字)   数字转为字符，ascii的反函数
asciistr(字符串)  对字符串进行转换，如果有非ascii码字符('\'除外，它会被转为'\005C')，转为\XXXX 的形式，XXXX是对应的十六进制值 select ASCIISTR('a串') from dual ; --> 'a\4E32'


Meta Data
V$VERSION    查看版本信息
V$SESSION    查看会话信息
DUAL         单行单列的伪表

