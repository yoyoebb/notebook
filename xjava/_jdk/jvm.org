* main jvm
  目前有以下主流JVM实现，他们都要遵循JVM规范：
  + HotSpot VM
  + JRockit VM(1.8已经和HotSpot VM合并)
  + J9 VM
  + Zing VM

* jvm memory structure
  规范中定义了JVM内存结构包括：
  1. 程序计数器
     它是一块较小的内存区域，作为当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成。【需要汇编知识】

  2. JVM栈（Java Virtual Machine Stacks）。线程私有，生命周期与线程相同。
     用途：描述JAVA方法执行的内存模型。每个方法被执行时，都会同时创建一个Stack Frame，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直到执行完成，就是一个Stack Frame从入栈到出栈的过程。

     局部变量表(所需的内存空间在编译期就完成了分配)：
     1. 各种基本数据类型(boolean, byte, char, short, int, float, long, double)，long 和 double类型数据占两个局部变量空间
     2. 对象引用，基于不同的虚拟机实现，可能是指向对象起始地址的引用指针，也有可能指向一个代表对象的句柄
     3. returnAddress类型，指向了一条字节码指令的地址。

     虚拟机规范中规定了栈实现的两种异常：
     a. StackOverflowError
        线程请求的栈深度大于虚拟机所允许的深度，如两个方法之间的递归调用
     b. OutOfMemoryError     
        栈进行动态扩展时，但无法申请足够内存时，抛出此异常

  3. 本地方法栈
     与JVM Stack类似，只是为了虚拟机调用本地方法服务，有些虚拟机直接把本地方法栈和虚拟机栈合为一体。

  4. JAVA Heap
     被所有线程共享的内存区域，在虚拟机启动时创建，用于存放对象实例。当前主流的虚拟机都是按照可扩展来实现堆区(通过 -Xmx和-Xms控制)

     如果堆区中没有内存完成实例分配，也无法再扩展时，将会抛出OutOfMemoryError。

  5. 方法区
     被所有线程共享的内存区域，用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的回收 和 对类型的卸载。相比堆群，回收条件比较苛刻。

     方法区无法满足内存分配需求时，也会抛出OutOfMemoryError

     运行时常量池：方法区的一部分。
     a. 在编译时，Class文件中有一项用于存放各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。
     b. 运行时，也有可能会产生新的常量池，譬如String.intern()方法。

  6. 直接内存
     JDK1.4的NIO，引入了一种基于Channel和Buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。

* 内存不足(OutOfMemoeryError)总结：
| JVM栈    |                      | uncable to create new native thread |
| 方法区   | 永生代               | PermGen space                       |
| 直接内存 |                      |                                     |
| 堆区     | Eden/Survivor/老年代 | heap space                          |

   + 设置方法区内存：
     -XX:PermSize     永久区初始大小
     -XX:MaxPermSize  永久区最大值
   + 设置堆区内存：
     -Xms:   堆初始大小
     -Xmx:   堆最大值
     -Xmn:   年轻代的大小
     -Xms -Xmx最好设置为相同值，避免反复动态调整堆区大小。
     e.g：Java -Xms1024m -Xmx1024m -Xmn812m

* 数据存放
   程序运行时时，有5个不同的地方可以存放数据：
   1. Registers
      处理器内部的寄存器，访问速度最快，但存储空间比较小。 在JAVA中程序无法使用
   2. Stack
      位于RAM中，在JAVA程序运行时存放非Object实例外的其他运行时资源：method、reference
   3. Heap
      位于RAM中，在JAVA程序运行时存放通过new或反射创建的Object实例
   4. Constant storage
      静态存储区，存放各类常量
   5. Non-RAM storage
      以字节流的形式存在，可以固化在文件、数据库中

* 对象访问的两种方式：
   Object obj = new Object() ;
   如果这句代码在方法中调用，能很清晰地体现出JVM栈区、JAVA堆区、方法区三者的联系。
   + 基于句柄访问的reference
     好处：对象被移动时，只会改变句柄中的实例数据指针，而reference本身不需要被修改。
   + 基于直接指针访问的reference
     好处：速度更快。(HotSpot采用)

* GC-堆内存垃圾回收
   在JAVA中，对象实例都是在Heap中创建，当没有任何引用指向该对象时，由JVM进行垃圾回收，不需要程序员主动销毁。

   Object 提供了一个finalize()回调方法用于JVM销毁对象前调用，但JVM只保证会销毁无用对象，但不保证何时会GC。

   JVM一般采用的是适应性垃圾回收，当可用内存减少到一定程度时，JVM才会GC，如果内存占用不高时，JVM可能会一直不GC。

** 怎么判断对象需要回收？
   + 引用计数算法： 无法避免对象之间互相循环引用的情况。
   + 根搜索算法：通过一系列名为“GC Roots”的对象作为起始点开始搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
     JAVA中可作为GC Roots的对象包括：
     a. 虚拟机栈中的引用的对象
     b. 方法区中的类静态属性引用的对象
     c. 方法区中的常量引用的对象
     d. 本地方法栈中JNI的引用的对象

** 回收算法
   垃圾回收(JDK提供了很多不同的GC收集器，分别适用于不同的场景)：
   1. 标记-清除算法： 效率不高、会产生大量不连续的内存碎片
   2. 复制算法： 需要在内存中划出专门的备份空间，对象存活率较高时效率会变低。
      商业虚拟机多采用此算法来回收新生代，IBM专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按1：1的比例来划分内存空间，而是将内存分为一块较大的Eden和两块较小的Survivor空间(8:1:1)，每次使用Eden和其中的一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地拷贝到另外一个Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。

      我们没法保证每次回收都只有不多于10%的对象存活，当超过的时候，需要依赖其他内存(老年代)进行分配担保。
   3. 标记-整理算法:  在标记-清除算法上进行加工，对存活对象进行整理后清除掉端边界以外的内存。适用于回收老年代

** 堆内存中的对象分配
   1. 对象优先在新生代Eden内存区分配
   2. 大对象直接进入老年代分配
   3. 长期存活的对象会被从Survivor挪到老年代。
      判断依据：熬过了多次Minor GC、动态对象年龄判断
