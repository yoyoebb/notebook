* Number
** Integer

** Float/Double
    所有的浮点运算都遵循IEEE 754规范。特别的，java中定义了三个特殊的浮点值来标识overflows和errors:
    + Positive infinity  表示正无穷大，如: =1.0/0=
    + Negative infinity  表示负无穷大，如: =-1.0/0=
    + NaN (not a number) 表示非数字，如: =0.0/0=

    尽管在Double类中定义了这三个特殊值对应的常量，但我们不能直接用==进行判断
    #+BEGIN_SRC java
      if (x == Double.NaN)  // is never true
      if (Double.isNaN(x))  // 这才是正确的判断方法
    #+END_SRC

    浮点数精度丢失
    由于小数的二进制显示存在精度丢失，java中的float/double同样有此类问题。当需要精准计算(金融)或精准判断(比较)时，不能使用浮点数。

    Float/Double的toString()方法使用了sun.misc.FloatingDecimal进行格式化，输出对应的10进制字符串时做了部分修正。
    #+BEGIN_SRC java
      System.out.println(2.0 - 1.1)       //the result is 0.8999999999999999
      System.out.println(0.9f)            //the result is 0.9
      System.out.println(0.9 == 2.0-1.1)  //the result is false 
    #+END_SRC
     
** Cast
    auto cast
    当把范围较小的数字类型赋值给范围较大的数字类型时，会对值进行自动转换，转换规则为：byte -> short(char) -> int -> long -> float -> double

    当表达式有多种数字类型混合计算时，有以下规则：
    1. 有任意变量为double，则结果为double，否则
    2. 有任意变量为float，则结果为float，否则
    3. 有任意变量为long，则结果为long，否则
    4. 表达式结果为int

    force cast (从大到小)
    当把范围大的数字类型赋值给范围小的数字类型时，会提示类型不符，这时需要显式类型转换（使用cast操作符()，超过范围会溢出）
    #+BEGIN_SRC java
      double x = 9.997;
      int nx = (int)x;   // x=9
    #+END_SRC

* String
** String
在Java中，所有的字符串都被视为String类的对象，其底层是一个Char[]。由于字符串如此之重要，String被设计为Immutable，其对象一旦被创建，你再也无法更改内部的Char[]的值。String提供的更改操作，都会返回一个新的字符串对象。

String类型引用变量的赋值可以分为两种情况：
#+BEGIN_EXAMPLE
// 以字符串常量方式赋值，引用指向字符串常量
String a = "hello" ;

// 以new 对象的方式赋值，引用指向堆对象
String b = new String("hello") ;

a == b           //结果是false，因为引用地址不同
a.equals(b)      //结果是true，因为String override了equals方法，比较的是内部char[]
a == b.intern()  //结果是true，因为intern会返回对应的字符串常量，而相同字符串常量地址是唯一的
#+END_EXAMPLE

一些常用的String操作：
 - substrings
#+BEGIN_EXAMPLE
String greeting = "hello" ;
String sub = greeting.substring(0,3) ;    //sub = "hel"
#+END_EXAMPLE
 - concatenation
#+BEGIN_EXAMPLE
String a = "this is " ;
String b = a + "a String" ;   // b = "this is a String"

String all = String.join("/","S","M","L","XL") ;  // all = "S/M/L/XL"
#+END_EXAMPLE
 - test null or empty
#+BEGIN_EXAMPLE
// test null
if (str == null)

// test empty - ""(空字符串)
if (str != null && str.length() == 0)
if ("".equals(str))
#+END_EXAMPLE
 - length
#+BEGIN_EXAMPLE
// char[]，也即是code unit的长度
String greeting = "hello" ;
int n = greeting.length() ;   // n == 5

// 获取code point的长度
int nCP = greeting.codePointCount(0, greeting.length())
#+END_EXAMPLE

更多String的操作方法可以参考API文档
** Building Strings
由于String immutable的特性，我们在通过字符串连接、截取等操作来构造新的字符串时，往往会生成大量临时字符串对象，即影响效率，也浪费内存。所以我们通常使用StringBuilder来构造字符串对象。
#+BEGIN_EXAMPLE
StringBuilder builder = new StringBuilder() ;
builder.append('a').append(str).append("hello") ;
String target = builder.toString() ;
#+END_EXAMPLE
 * StringBuilder (JSE5.0)的前身是StringBuffer，后者被设计为线程安全。所以单线程环境通常使用StringBuilder，效率更高。
* Date
